# Effects of Type Erasure and Bridge Methods 类型擦除的影响和桥接方法

Sometimes type erasure causes a situation that you may not have anticipated. The following example shows how this can occur. The example (described in [Bridge Methods](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods)) shows how a compiler sometimes creates a synthetic method, called a bridge method, as part of the type erasure process.  
有时类型擦除会导致你可能无法预料的情况。以下示例显示了这种情况的发生方式。该示例（在[桥接方法](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods)中进行了介绍）展示了编译器有时如何创建一个synthetic方法，称为桥接方法，作为类型擦除过程的一部分。

Given the following two classes:  
给定以下两个类：

```java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

Consider the following code:  
考虑下面的代码：

```java
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     
Integer x = mn.data;    // Causes a ClassCastException to be thrown.
```

After type erasure, this code becomes:  
类型擦除过后，代码变为：

```java
MyNode mn = new MyNode(5);
Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
n.setData("Hello");
Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
```

Here is what happens as the code is executed:  
这就是代码执行时发生的情况：

- `n.setData("Hello");` causes the method `setData(Object)` to be executed on the object of class `MyNode`. (The `MyNode` class inherited `setData(Object)` from `Node`.)  
`n.setData("Hello");`使`MyNode`对象上的方法`setData(Object)`被执行。（`MyNode`类从`Node`中继承了`setData(Object)` 方法）

- In the body of `setData(Object)`, the data field of the object referenced by `n` is assigned to a `String`.  
在 `setData(Object)`方法体中，`n`引用的对象的数据字段被赋值了一个`String`。

- The data field of that same object, referenced via `mn`, can be accessed and is expected to be an integer (since `mn` is a `MyNode` which is a `Node<Integer>`).  
通过`mn`引用的同一对象的数据字段，可以被访问，并且期望是一个`integer`（因为`mn`是`MyNode`，所以是`Node<Integer>`）

- Trying to assign a `String` to an `Integer` causes a `ClassCastException` from a cast inserted at the assignment by a Java compiler.  
试图把`String`分配给`Integer`导致Java编译器在分配时插入强制转换而产生`ClassCastException`异常。

## Bridge Methods 桥接方法

When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a *bridge method*, as part of the type erasure process. You normally don't need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.  
在编译一个扩展参数化类或实现参数化接口的类或接口时，作为类型擦除过程的一部分，编译器可能需要创建一个称为*bridge method*的synthetic方法。你通常不必担心桥接方法，但是如果其中一个出现在堆栈跟踪中，你可能会感到困惑。

After type erasure, the `Node` and `MyNode` classes become:  
类型擦除后，`Node`和`MyNode`类变为：
```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

After type erasure, the method signatures do not match. The `Node` method becomes `setData(Object)` and the `MyNode` method becomes `setData(Integer)`. Therefore, the `MyNode` `setData` method does not override the `Node` `setData` method.  
类型擦除后，方法签名不匹配。` Node`方法变为`setData(Object)`，而`MyNode`方法变为`setData(Integer)`。 因此，`MyNode`的`setData`方法不会覆盖`Node`的`setData`方法。

To solve this problem and preserve the [polymorphism](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html) of generic types after type erasure, a Java compiler generates a bridge method to ensure that subtyping works as expected. For the `MyNode` class, the compiler generates the following bridge method for `setData`:  
为了解决此问题并在类型擦除后保留泛型类型的[多态性](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html) ，Java编译器生成了一个桥接方法来确保子类型能够按预期工作。 对于`MyNode`类，编译器为`setData`生成以下桥接方法：

```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

As you can see, the bridge method, which has the same method signature as the `Node` class's `setData` method after type erasure, delegates to the original `setData` method.  
如你所见，在类型擦除之后，具有与`Node`类的`setData`方法相同的方法签名的桥接方法将委托给原始的`setData`方法。